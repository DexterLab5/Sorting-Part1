1. Ако удвоим arr.size какво ще стане? Средно статистически цикалът ще се изпънява 2 пъти повече.
2. Какво може да кажем за search функцията? Функцията е добра, ако не знаем какво представлява масива. Може да се каже че е ефикасна,
защото Binary search изисква масива да е подреден.
3. Или горната фукнция ще е пропорционална на arr1.size * arr2.size времева сложност.
4.1
a. 0(n^2)
b. 0(n*2), значи 0(n)
c. 0(n)
5. 45 20 67 13 27 63
разменяме 45 с 13, масивът става 13 20 67 45 27 63
20 остава
разменяме 67 с 27, масивът става 13 20 27 45 67 63
45 остава
разменяме 67 и 63, масивът става 13 20 27 45 63 67
6. 45 20 67 13 27 63
разменяме 45 и 20, разменяме 67 и 13, разменяме 67 и 27, разменяме 67 и 63. 20 45 13 27 63 67
разменяме 45 и 13, разменяме 45 и 27. 20 13 27 45 63 67
разменяме 20 и 13. 13 20 27 45 63 67
7. 40 35 80 75 60 90 70 75 50 22
35 идва на мястото на 40 и 40 на неговото. 35 40 80 75 60 90 70 75 50 22
75 идва след 40. 35 40 75 80 60 90 70 75 50 22
60 идва след 40. 35 40 60 75 80 90 70 75 50 22
70 идва след 60. 35 40 60 70 75 80 90 75 70 22
75 идва след 75. 35 40 60 70 75 75 80 90 70 22
70 идва след 70. 35 40 60 70 70 75 75 80 90 22
22 е първо. 22 35 40 60 70 70 75 75 80 90